/*
 *
 *  Copyright (C) 2010, 2011, 2012 The Europa Barbarorum Team
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *      * Redistributions of source code must retain the above copyright
 *        notice, this list of conditions and the following disclaimer.
 *      * Redistributions in binary form must reproduce the above copyright
 *        notice, this list of conditions and the following disclaimer in the
 *        documentation and/or other materials provided with the distribution.
 *      * Neither the name of The Europa Barbarorum Team nor the
 *        names of other contributors may be used to endorse or promote products
 *        derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL The Europa Barbarorum Team BE LIABLE FOR ANY
 *  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package org.europabarbarorum.cuf.gui.support;

import java.awt.Component;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.util.List;
import javax.script.ScriptEngineFactory;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.filechooser.FileFilter;
import org.europabarbarorum.cuf.shell.Shell;
import org.europabarbarorum.cuf.support.PathParser;
import org.europabarbarorum.cuf.support.PathParser.Glob;

/**
 * A class to provide an easy way to work with the combination of a textfield and a
 * file chooser dialog (accessed through clicking a button) for providing a file selection.
 * @author Johan Ouwerkerk
 */
public final class FileInput {

    /**
     * Create a new {@link FileInput}.
     * @param description a description of the {@link FileFilter} to use for
     * filtering files in a file chooser UI.
     * @param access the {@link Access} mode against which file selections are validated
     * @param shell the {@link Shell} which provides context for parsing path names.
     * @param parent  the {@link Component} on top which file dialogs are displayed when the user
     * clicks the button generated by {@link #getButton() }
     */
    public FileInput (FileDescription description,
                      Access access,
                      Shell shell,
                      Component parent) {
        this(description,
             access,
             shell == null ? null : shell.pathParser(),
             parent);
    }

    /**
     * Create a new {@link FileInput}.
     * @param description a description of the {@link FileFilter} to use for
     * filtering files in a file chooser UI.
     * @param access the {@link Access} mode against which file selections are validated
     * @param ctx the {@link PathParser} which provides context for parsing path names.
     * @param parent  the {@link Component} on top which file dialogs are displayed when the user
     * clicks the button generated by {@link #getButton() }
     */
    public FileInput (FileDescription description,
                      Access access,
                      PathParser ctx,
                      Component parent) {
        this.description = description;
        this.parser = ctx == null ? new Glob() : ctx;
        this.parent = parent;
        this.request = access;
    }
    private Access request = Access.Read;

    /**
     * Set the {@link Access} type against which file input is validated.
     * @param request the {@link Access} mode against which file input is validated.
     */
    public void setRequest (Access request) {
        this.request = request;
    }
    private JButton button = null;
    private Component parent = null;
    private ActionListener listener = null;
    private FileDescription description = null;
    private SettingField textField = new SettingField();
    private PathParser parser = null;
    private String finalValue = null;

    /**
     * Get the textfield component this {@link FileInput} offers for entering a 
     * file path.
     * @return the {@link SettingField} used by this {@link FileInput}.
     */
    public SettingField getTextField () {
        return textField;
    }

    /**
     * Configure this {@link FileInput} with a file filter to use when displaying a
     * file chooser UI.
     * @param description the {@link FileDescription} to use.
     */
    public void setDescription (FileDescription description) {
        this.description = description;
    }

    /**
     * Get a description of the file filter used by this {@link FileInput}.
     * @return the {@link FileDescription} object used by this {@link FileInput}.
     */
    public FileDescription getDescription () {
        return description;
    }

    private FileFilter createFilter (final String desc,
                                     final String[] extensions) {
        return new FileFilter() {

            @Override
            public boolean accept (File f) {
                if (f.isDirectory()) {
                    return true;
                }
                String file = f.toString();
                for (String ext : extensions) {
                    if (file.endsWith(ext)) {
                        return true;
                    }
                }
                return false;
            }

            @Override
            public String getDescription () {
                return desc;
            }
        };
    }

    /**
     * Pops up a {@link JFileChooser} dialog to obtain file input from the user. This file chooser supports the
     * selection of a single file only.
     * @param approveText the text for the button which confirms the file selection and closes the dialog.
     * @return the selected {@link File} or null if no file was selected.
     */
    public File useFileChooser (String approveText) {
        JFileChooser jfc = new JFileChooser(parser.getPWD());

        if (description == null || description.includeAllTypesFilter()) {
            jfc.setFileFilter(
                    getFilter(jfc.getAcceptAllFileFilter()));
        }
        if (description != null) {

            jfc.setFileFilter(getFilter(createFilter(
                    description.description(),
                    description.getExtensions())));
        }
        jfc.setAcceptAllFileFilterUsed(false);
        if (jfc.showDialog(parent, approveText) == JFileChooser.APPROVE_OPTION) {
            return jfc.getSelectedFile();
        }
        else {
            return null;
        }
    }

    private ActionListener getListener () {
        if (listener == null) {
            listener = new ActionListener() {

                @Override
                public void actionPerformed (ActionEvent e) {
                    Object o=useFileChooser(button.getText());
                    if(o!=null) { // will be null if file chooser is canceled
                        textField.setValue(o.toString());
                    }
                }
            };
        }
        return listener;
    }

    /**
     * Auxiliary method to set focus on the button which pops up a {@link JFileChooser}
     * instead of the {@link SettingField}. This method does nothing if {@link #getButton() } has
     * not been used first (to put the button in the GUI).
     * @param inWindow use true to make this method use {@link Component#requestFocusInWindow() }
     * instead of {@link Component#requestFocus() }. True is appropriate when the GUI is fully
     * constructed but not yet visible, false is appropriate when the GUI is already visible.
     */
    public void focusButton (boolean inWindow) {
        if (button != null) {
            button.setSelected(true);
            if (inWindow) {
                button.requestFocusInWindow();
            }
            else {
                button.requestFocus();
            }
        }
    }

    /**
     * Validates the file path specified in this {@link FileInput}, and marks the
     * components if the input is invalid (displays an error message).
     * @return true if file input given is valid, false if not.
     */
    public boolean check () {
        return isValid() ? true : markInvalid();
    }

    private boolean markInvalid () {
        if (finalValue == null) {
            String message = description == null
                    ? Messages.DefaultFileError.getText()
                    : description.errorMessage();

            textField.reset(message);
            focusButton(false);
        }
        return false;
    }

    /**
     * Get the {@link JButton} which pops up a {@link JFileChooser} when clicked.
     * @return the button associated with this {@link FileInput}.
     */
    public JButton getButton () {
        if (this.button == null) {
            this.button = new JButton();
            this.button.addActionListener(getListener());
        }
        return button;
    }

    /**
     * Dispose of the components.
     * After this method has been called {@link #getValue() } will still continue to work.
     */
    public void dispose () {
        this.finalValue = getValue();
        this.button = null;
        this.textField = null;
        this.listener = null;
    }

    /**
     * Get the file path selected by the user.
     * @return the text entered by in the {@link SettingField} used, or
     * null if no text was entered (yet).
     */
    public String getValue () {
        if (textField == null) {
            return finalValue;
        }
        textField.drop();
        String val = textField.getValue();
        return val == null || val.equals("") ? null : val;
    }

    private FileFilter getFilter (final FileFilter inner) {
        return new FileFilter() {

            @Override
            public boolean accept (File f) {
                return inner.accept(f) && fileValid(f, true);
            }

            @Override
            public String getDescription () {
                return inner.getDescription();
            }
        };
    }

    private boolean fileValid (File f, boolean allowDirs) {
        if (f == null || (f.isDirectory() && !allowDirs)) {
            return false;
        }
        switch (request) {
            case Read:
                return f.canRead();
            case Write:
                if (!f.canWrite()) {
                    File p = f.getParentFile();
                    if (f.exists() || p == null || !p.canWrite()) {
                        return false;
                    }
                }
                return true;
            case ReadWrite:
                return f.canRead() && f.canWrite();
            default:
                return false;
        }
    }

    /**
     * Checks whether the currently selected file (or lack thereof) is valid input
     * according to the given {@link FileDescription} and {@link Access} mode.
     * @return true if the file input is valid, false if not.
     */
    public boolean isValid () {
        String val = getValue();
        if (val == null) {
            return description.isOptional();
        }

        File f = parser.parsePath(val);
        return fileValid(f, description.allowDirectories());
    }

    /**
     * Encapsulates the essential data used for a {@link FileFilter}.
     */
    public interface FileDescription {

        /**
         * Whether the user may omit selecting a valid file.
         * @return true if the user may leave a {@link FileInput} empty.
         */
        boolean isOptional ();

        /**
         * Whether or not directories are allowed to be selected.
         * @return true if the user can select directories, false if only ordinary
         * files are allowed.
         */
        boolean allowDirectories ();

        /**
         * Whether or not the {@link JFileChooser} GUI should offer a “All file types”
         * filter that allows the user to input arbitrary file names.
         * @return true if the “All file types” filter should be enabled, false if it
         * should be disabled.
         */
        boolean includeAllTypesFilter ();

        /**
         * Get suggested extensions of files to look for in file dialog (filters).
         * @return an array of filename suffixes.
         */
        String[] getExtensions ();

        /**
         * Defines a short descriptive label to display in a {@link JFileChooser}
         * GUI for selecting the corresponding {@link FileFilter}.
         * @return the text to display in the list of file filters that may be used
         * to narrow down the selection of files in a GUI.
         */
        String description ();

        /**
         * Defines a short descriptive error message to display in a {@link SettingField} when
         * the user inputs invalid file data.
         * @return the text to display in a {@link SettingField}
         * when {@link FileInput#check() } fails.
         */
        String errorMessage ();
    }

    //<editor-fold defaultstate="collapsed" desc="Create descriptions from Shell">
    /**
     * Create a {@link FileDescription} from a {@link Shell}.
     * This method is a convenience version for
     * {@link #createDescription(org.europabarbarorum.cuf.shell.Shell, boolean) } which
     * assumes that a file selection is required.
     * @param context the context {@link Shell} to use for creating the description.
     * @return a {@link FileDescription} suitable for selecting
     * appropriate script files for execution in the given {@link Shell}.
     */
    public static FileDescription createDescription (final Shell context) {
        return createDescription(context, false);
    }

    /**
     * Create a {@link FileDescription} from a {@link Shell}.
     * @param context the context {@link Shell} to use for creating the description.
     * @param optional whether or not file selection is required.
     * @return a {@link FileDescription} suitable for selecting
     * appropriate script files for execution in the given {@link Shell}.
     * @see #createDescription(org.europabarbarorum.cuf.shell.Shell) 
     */
    public static FileDescription createDescription (final Shell context,
                                                     final boolean optional) {
        return new FileDescription() {

            private final String language = context.loadedLanguage();
            private final String[] extensions = init(context);

            private String[] init (Shell context) {
                String[] array = new String[] { "" };
                ScriptEngineFactory fact = context.getFactory();
                List<String> exts = fact.getExtensions();
                return exts == null ? array : exts.toArray(array);
            }

            @Override
            public boolean isOptional () {
                return optional;
            }

            @Override
            public boolean allowDirectories () {
                return false;
            }

            @Override
            public boolean includeAllTypesFilter () {
                return true;
            }

            @Override
            public String[] getExtensions () {
                return extensions;
            }

            @Override
            public String description () {
                return Messages.ScriptDescription.format(language);
            }

            @Override
            public String errorMessage () {
                return Messages.InvalidScriptName.getText();
            }
        };
    }//</editor-fold>

    //<editor-fold defaultstate="collapsed" desc="AnyInputDescription">
    /**
     * A default accept-all {@link FileDescription} for use a dummy value.
     */
    public static class AnyInputDescription implements FileDescription {

        private final boolean dir, opt;

        /**
         * Create a new {@link AnyInputDescription}.
         * @param dir whether or not to accept directories.
         * @param opt whether or not file selection is optional.
         */
        public AnyInputDescription (boolean dir, boolean opt) {
            this.dir = dir;
            this.opt = opt;
        }

        @Override
        public boolean isOptional () {
            return opt;
        }

        @Override
        public boolean allowDirectories () {
            return dir;
        }

        @Override
        public boolean includeAllTypesFilter () {
            return false;
        }

        @Override
        public String[] getExtensions () {
            return new String[] { "" };
        }

        @Override
        public String description () {
            return (dir
                    ? Messages.AnyFileDirDescription
                    : Messages.AnyFileDescription).getText();
        }

        @Override
        public String errorMessage () {
            return Messages.DefaultFileError.getText();
        }
    }//</editor-fold>

    /**
     * Access modes which specify how a file is used.
     * This is a flag to tell a {@link FileInput} how a file path should be validated,
     * since different uses for a file may require different file permissions
     * for the intended operations to succeed (and hence limit the subset of valid file paths in different ways).
     */
    public enum Access {

        /**
         * The file selected is intended to be read.
         */
        Read,
        /**
         * The file selected is intended to be written.
         */
        Write,
        /**
         * The file selected is intended to be both read and written.
         */
        ReadWrite;
    }
}
